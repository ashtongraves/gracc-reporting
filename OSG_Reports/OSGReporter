#!/usr/bin/python

import os
import inspect
import re
import json
import traceback
import sys

from elasticsearch_dsl import Search

parentdir = os.path.dirname(
    os.path.dirname(
        os.path.abspath(
            inspect.getfile(
                inspect.currentframe()
            )
        )
    )
)
os.sys.path.insert(0, parentdir)

import Configuration
from Reporter import Reporter, runerror

logfile = 'osgreporter.log'


def key_to_lower(bucket):
    return bucket.key.lower()

@Reporter.init_reporter_parser
def parse_opts(parser):
    """
    Specific argument parser for this report.  The decorator initializes the
    argparse.ArgumentParser object, calls this function on that object to
    modify it, and then returns the Namespace from that object.
    :param parser: argparse.ArgumentParser object that we intend to add to
    :return: None
    """
    # Report-specific args
    parser.add_argument("-r", "--report-type", dest="report_type",
                        help="Report type (OSG, XD. or OSG-Connect")


class OSGReporter(Reporter):
    def __init__(self, report_type, config, start, end=None, isSum=True,
                 verbose=False, no_email=False, is_test=False, template=None):
        Reporter.__init__(self, report_type, config, start, end, verbose, raw=False,
                          no_email=no_email, is_test=is_test, template=template)
        self.report_type = self.validate_report_type(report_type)
        self.header = ["Project Name", "PI", "Institution", "Field of Science",
                     "Wall Hours"]
        self.title = "{0} Project Report for {1}-{2}".format(self.report_type,
                                                             self.start_time,
                                                             self.end_time)
        self.logfile = logfile
        self.logger.info("Report Type: {0}".format(self.report_type))
        self.isSum = isSum

    def validate_report_type(self, report_type):
        validtypes = {"OSG": "OSG-Direct", "XD": "OSG-XD",
                      "OSG-Connect": "OSG-Connect"}
        if report_type in validtypes:
            self.title = "{0} Projects {1} - {2}".format(
                validtypes[report_type], self.start_time, self.end_time)
            return report_type
        else:
            raise Exception("Must use report type {0}".format(
                ', '.join((name for name in validtypes)))
            )

    def query(self):
        """Method to query Elasticsearch cluster for OSGReporter information"""
        # Gather parameters, format them for the query
        starttimeq = self.dateparse_to_iso(self.start_time)
        endtimeq = self.dateparse_to_iso(self.end_time)

        probes = [_.strip("'") for _ in re.split(",", self.config.get(
            "query", "{0}_probe_list".format(self.report_type)))]

        if self.verbose:
            print probes

        print self.indexpattern
        # self.indexpattern = 'gracc.osg.summary'

        # Elasticsearch query and aggregations
        s = Search(using=self.client, index=self.indexpattern) \
                .filter("range", EndTime={"gte": starttimeq, "lt": endtimeq}) \
                .filter("range", WallDuration={"gt": 0}) \
                .filter("terms", ProbeName=probes) \
                .filter("term", ResourceType="Payload")[0:0]
        # Size 0 to return only aggregations
        # Bucket, metric aggs
        Bucket = s.aggs.bucket("group_ProjectName", "terms", field="ProjectName",
                               size=2**31-1, order={"_term":"asc"},
                               missing="UNKNOWN")\
                    .bucket("group_PIName", "terms", field="OIM_PIName", missing="UNKNOWN")\
                    .bucket("group_Organization", "terms", field="OIM_Organization", missing="UNKNOWN")\
                    .bucket("group_FOS", "terms", field="OIM_FieldOfScience", missing="UNKNOWN")
        Bucket.metric("CoreHours_sum", "sum", field="CoreHours")

        return s

    def runquery(self):
        """Execute the query and check the status code before returning the response"""
        resultset = self.query()
        t = resultset.to_dict()
        if self.verbose:
            print json.dumps(t, sort_keys=True, indent=4)
            self.logger.debug(json.dumps(t, sort_keys=True))
        else:
            self.logger.debug(json.dumps(t, sort_keys=True))

        try:
            response = resultset.execute()
            if not response.success():
                raise
            results = response.aggregations
            self.logger.debug("Elasticsearch query executed successfully")
            return results
        except Exception as e:
            print e, "Error accessing Elasticsearch"
            sys.exit(1)

    @staticmethod
    def is_missing(string):
        """Check to see a field is missing info"""
        if string == "N/A" or string == "UNKNOWN":
            return True
        return False

    def get_project_info(self):
        """Method to handle logic of what to do with projects with missing OIM info"""
        if self.report_type == "XD":
            pass
        elif self.report_type == "OSG":
            pass
        elif self.report_type == "OSG-Connect":
            pass
        return

    def generate_report_file(self):
        """Takes data from query response and parses it to send to other
        functions for processing"""
        results = self.runquery()

        for pname_bucket in self.sorted_buckets(results.group_ProjectName,
                                                key=key_to_lower):
            pname = pname_bucket.key
            if self.is_missing(pname):
                pass    # If no ProjectName, then email osg-support
            for pi_bucket in pname_bucket.group_PIName.buckets:
                pi = pi_bucket.key
                if self.is_missing(pi):
                    self.get_project_info()
                for org_bucket in pi_bucket.group_Organization.buckets:
                    org = org_bucket.key
                    for fos_bucket in org_bucket.group_FOS.buckets:
                        fos = fos_bucket.key
                        yield (pname, pi, org, fos, fos_bucket.CoreHours_sum.value)

    # def generate_report_file(self, report):
    #     pass

    def format_report(self, report=None):
        report = {}
        for name in self.header:
            if name not in report:
                report[name] = []

        for result_tuple in self.generate_report_file():
            pname, pi, org, fos, wallhrs = result_tuple
            if self.verbose:
                print "{0}\t{1}\t{2}\t{3}\t{4}".format(pname,
                                                       pi, org, fos,
                                                       wallhrs)
            report["Project Name"].append(pname)
            report["PI"].append(pi)
            report["Institution"].append(org)
            report["Field of Science"].append(fos)
            report["Wall Hours"].append(wallhrs)

        if self.isSum:
            report["Project Name"].append("Total")
            report["PI"].append("")
            report["Institution"].append("")
            report["Field of Science"].append("")
            report["Wall Hours"].append(sum(report["Wall Hours"]))

        return report

    def run_report(self):
        self.send_report(self.title)


if __name__=="__main__":
    
    args = parse_opts()

    config = Configuration.Configuration()
    config.configure(args.config)

    try:
        r = OSGReporter(args.report_type,
                        config,
                        args.start,
                        args.end,
                        template=args.template,
                        isSum=True,
                        verbose=args.verbose,
                        is_test=args.is_test,
                        no_email=args.no_email)
        # print args.no_email
        r.run_report()
        # r.send_report()
        r.logger.info("OSG Project Report executed successfully")
    except Exception as e:
        with open(logfile, 'a') as f:
            f.write(traceback.format_exc())
        print >> sys.stderr, traceback.format_exc()
        runerror(config, e, traceback.format_exc())
        sys.exit(1)
    sys.exit(0)

